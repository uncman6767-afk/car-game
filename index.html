<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pro Beam.MG Clone</title>
<style>
body { margin:0; overflow:hidden; background:#111; }
canvas { display:block; }
#hud {
  position:absolute; top:10px; left:10px; color:white; font-family:Arial; font-size:20px;
}
</style>
</head>
<body>
<div id="hud">
  <div id="speedometer">Speed: 0 km/h</div>
  <div id="score">Score: 0</div>
  <div id="boosts">Boosts: 0</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>
<script>

// === Scene Setup ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,5,15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// === Lights ===
const ambient = new THREE.AmbientLight(0xffffff,0.3);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(10,20,10);
dirLight.castShadow = true;
scene.add(dirLight);

// === Road Segments ===
const roadWidth = 10;
let roadSegments = [];
const laneCount = 3;

function createRoadSegment(z, curve=0){
  const roadGeo = new THREE.PlaneGeometry(roadWidth, 50, 1,1);
  const roadMat = new THREE.MeshStandardMaterial({color:0x333333});
  const road = new THREE.Mesh(roadGeo, roadMat);
  road.rotation.x = -Math.PI/2;
  road.position.z = z;
  road.position.x = curve;
  scene.add(road);
  return road;
}

// Create initial road segments with slight curves
for(let i=0;i<10;i++){
  const curve = Math.sin(i/5)*3; 
  roadSegments.push(createRoadSegment(-50*i, curve));
}

// Lane Lines
const laneLines = [];
for(let i=1;i<laneCount;i++){
  for(let j=0;j<10;j++){
    const lineGeo = new THREE.PlaneGeometry(0.2,50);
    const lineMat = new THREE.MeshStandardMaterial({color:0xffffff});
    const line = new THREE.Mesh(lineGeo,lineMat);
    line.rotation.x = -Math.PI/2;
    line.position.x = -roadWidth/2 + i*(roadWidth/laneCount) + Math.sin(j/5)*3;
    line.position.z = -50*j;
    scene.add(line);
    laneLines.push(line);
  }
}

// === Player Car ===
const playerGeo = new THREE.BoxGeometry(1,1,2);
const playerMat = new THREE.MeshStandardMaterial({color:0x0000ff});
const playerCar = new THREE.Mesh(playerGeo, playerMat);
playerCar.position.y = 0.5;
playerCar.position.z = 0;
playerCar.castShadow = true;
scene.add(playerCar);

// === AI Cars & Boosts ===
const aiCars = [];
const aiColors = [0xff0000,0xffff00,0x00ff00,0xffa500,0x800080];
const boosts = [];

// Game Variables
let speed=0, score=0, boostCount=0;
const keys = {};

// Controls
document.addEventListener('keydown', e=>keys[e.key]=true);
document.addEventListener('keyup', e=>keys[e.key]=false);

// === Spawn AI Cars ===
function spawnAICar(){
  const lane = (Math.floor(Math.random()*laneCount)-1)*(roadWidth/laneCount);
  const color = aiColors[Math.floor(Math.random()*aiColors.length)];
  const carGeo = new THREE.BoxGeometry(1,1,2);
  const carMat = new THREE.MeshStandardMaterial({color:color});
  const car = new THREE.Mesh(carGeo,carMat);
  car.position.set(lane,0.5,-50-Math.random()*50);
  car.speed = 0.2 + Math.random()*0.6;
  scene.add(car);
  aiCars.push(car);
}

// === Spawn Boosts ===
function spawnBoost(z){
  const boostGeo = new THREE.SphereGeometry(0.5,16,16);
  const boostMat = new THREE.MeshStandardMaterial({color:0x00ffff});
  const boost = new THREE.Mesh(boostGeo, boostMat);
  const lane = (Math.floor(Math.random()*laneCount)-1)*(roadWidth/laneCount);
  boost.position.set(lane,0.5,z);
  scene.add(boost);
  boosts.push(boost);
}

// === Update Function ===
function update(){
  // Player controls & physics
  if(keys['ArrowUp']) speed += 0.05;
  if(keys['ArrowDown']) speed -= 0.02;
  if(keys['ArrowLeft']) playerCar.position.x -= 0.15;
  if(keys['ArrowRight']) playerCar.position.x += 0.15;
  speed *= 0.98;
  if(speed<0) speed=0;
  if(playerCar.position.x<-roadWidth/2+0.5) playerCar.position.x=-roadWidth/2+0.5;
  if(playerCar.position.x>roadWidth/2-0.5) playerCar.position.x=roadWidth/2-0.5;

  // Road & lane lines movement
  roadSegments.forEach(r=>{
    r.position.z += speed;
    r.position.x = Math.sin(r.position.z/50)*3;
    if(r.position.z > 25) r.position.z -= 500;
  });
  laneLines.forEach(l=>{
    l.position.z += speed;
    l.position.x = -roadWidth/2 + (laneCount/3)*roadWidth/3 + Math.sin(l.position.z/50)*3;
    if(l.position.z > 25) l.position.z -= 500;
  });

  // AI cars
  aiCars.forEach(car=>{
    car.position.z += speed + car.speed;
    car.position.x += Math.sin(car.position.z/50)*0.02; // slight curve
    const dx = playerCar.position.x - car.position.x;
    const dz = playerCar.position.z - car.position.z;
    if(Math.abs(dx)<1 && Math.abs(dz)<1){
      alert('Game Over! Score: '+score);
      document.location.reload();
    }
    if(car.position.z>10){
      scene.remove(car);
      aiCars.splice(aiCars.indexOf(car),1);
      score++;
    }
  });

  // Boosts collection
  boosts.forEach(b=>{
    const dx = playerCar.position.x - b.position.x;
    const dz = playerCar.position.z - b.position.z;
    if(Math.abs(dx)<1 && Math.abs(dz)<1){
      boostCount++;
      speed += 0.5;
      scene.remove(b);
      boosts.splice(boosts.indexOf(b),1);
    }
  });

  // Camera follow
  camera.position.z = playerCar.position.z + 15;
  camera.position.x = playerCar.position.x;
  camera.lookAt(playerCar.position);

  // HUD update
  document.getElementById('speedometer').innerText = 'Speed: '+Math.round(speed*300)+' km/h';
  document.getElementById('score').innerText = 'Score: '+score;
  document.getElementById('boosts').innerText = 'Boosts: '+boostCount;
}

// Intervals
setInterval(spawnAICar, 1000);
setInterval(()=>spawnBoost(playerCar.position.z - 100 - Math.random()*200),5000);

// Animate
function animate(){
  requestAnimationFrame(animate);
  update();
  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>

